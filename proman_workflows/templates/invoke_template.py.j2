'''Python package.'''
# -*- coding: utf-8 -*-

import os
from typing import Any

from invoke import Argument, Collection, Program, task
from invoke.config import Config, merge_dicts
# from invoke import Executor

from . import config_tasks, package_tasks


# Configure Invoke
class WorkflowConfig(Config):
    prefix = 'workflows'

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        # XXX: overridden when adding configs from other collections
        if 'runtime_path' not in kwargs:
            runtime_path = os.path.join(os.getcwd(), 'workflows.yaml')
            if os.path.exists(runtime_path):
                print('fucking path exists')
                kwargs['runtime_path'] = runtime_path
            else:
                print('no fucking config')
        super().__init__(*args, **kwargs)
        self.set_runtime_path(runtime_path)
        self.load_runtime()
        print(self._runtime_path)

    @staticmethod
    def global_defaults():
        their_defaults = Config.global_defaults()
        my_defaults = {
            'run': {
                'echo': True,
            },
        }
        return merge_dicts(their_defaults, my_defaults)


# Config Invoke CLI default arguments
class WorkflowProgram(Program):
    def core_args(self):
        core_args = super(WorkflowProgram, self).core_args()
        extra_args = [
            Argument(names=('foo', 'Z'), help='Foo the bar')
        ]
        return core_args + extra_args


@task
def check(ctx):
    from pprint import pprint
    if hasattr(ctx, 'key'):
        print('great, key found')
    elif hasattr(ctx.config, 'key'):
        print('yey, key found')
    else:
        print('bleh, no key')
    pprint(ctx.config.__dict__)


# Assemble namespace for tasks
namespace = Collection()
namespace.add_task(check)
# namespace.add_collection(config_tasks, name='config')
# namespace.add_collection(package_tasks, name='package')
namespace.add_collection(Collection.from_module(config_tasks), name='config')
namespace.add_collection(Collection.from_module(package_tasks), name='package')
namespace.configure({'package': 'override-package'})
# print(namespace.task_names)
# print(namespace.serialized())

# this example should be in consuming library
# api = Executor(collection=namespace, config=WorkflowConfig())
# api.execute('package.mytask')
# api.execute(('config.yaml', {'filename': 'yepper.yaml'}))

# package metadata
__author__ = 'Jesse P. Johnson'
__title__ = 'Example Workflows'
__version__ = '0.1.0'
__license__ = 'Apache-2.0'

# workflow CLI endpoint callable by "program.run(['example', 'command'])"
program = WorkflowProgram(
    version=__version__,
    namespace=namespace,
    name=__title__,
    binary='workflow',
    binary_names=['workflow', 'wf'],
    config_class=WorkflowConfig
)
